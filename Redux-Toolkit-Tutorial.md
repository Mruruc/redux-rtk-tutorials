# Redux Toolkit 

Redux Toolkit is the official, opinionated, batteries-included toolset for efficient Redux development. It simplifies common Redux tasks and eliminates boilerplate code, making Redux development more intuitive and less error-prone.


## Why Redux Toolkit?
- Boilerplate Code:  Setting up Redux requires writing a lot of repetitive code, including action types, action creators, reducers, and switch statements.

- Immutability Complexity: Ensuring immutability in reducers can lead to deeply nested code or the need for utility libraries like immer or immutable.js.

- Configuration Overhead: Setting up the store with middleware, enhancers, and DevTools can be complex.

- Complex Async Logic: Handling asynchronous actions often requires additional middleware like redux-thunk or redux-saga, adding to the complexity.


## What is Exactly Redux Toolkit About ?

Redux Toolkit (RTK) is a package that encapsulates the best practices of Redux, providing utilities to simplify the most common tasks when building Redux applications. It includes functions to:

- Configure the store with good defaults (configureStore).
- Create reducers and actions in a concise way (createSlice).
- Simplify immutable update logic (createReducer).
- Handle asynchronous actions (createAsyncThunk).

## Key Feature of Toolkit 

1) `configureStore()`
Simplifies store configuration by setting up the Redux DevTools Extension and adding middleware like redux-thunk by default.


```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});

export default store;

```

2) `createSlice()` Generates action creators and action types automatically based on the reducers defined.

```js
import { createSlice } from '@reduxjs/toolkit';

const initialState = { value: 0 };

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment(state) {
      state.value += 1; // Mutation syntax is allowed
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;

```

### Main Points
- Concise Syntax: createSlice combines action creators and reducers in one place. ` and automatically generates action types based on the slice's name and reducer functions.` It significantly reduces boilerplate code.
- Mutable Code: Thanks to Immer (integrated into RTK), you can write "mutative" code that is actually immutable under the hood.
- Automatic Action Types: Action types are generated automatically based on the slice name and reducer keys.

```txt
Key takeaway: In createSlice(), every function in the reducers object defines both an action and a reducer. The action type is automatically created using the slice name and the reducer name.
```

#### Result
1) Each function in reducers defines a way to modify the state — this is the "reducer" part.
2) Redux Toolkit automatically generates an action creator for each reducer, which can be dispatched in your app.
3) The action type is based on the slice name and the reducer function name.

So, each reducer in the reducers object both:

Defines the state change when that action is dispatched.
Generates the corresponding action and action type for that state change.

### What hell is this `extraReducers` ?

1) Reducers in createSlice()
    The reducers field in createSlice() is used to define how the slice’s state should change in response to actions that are automatically generated by the slice itself.

    When you define a reducer inside the reducers object:

    The action creator and the action type are automatically generated for that reducer.
    The action type is tied directly to the slice's name and the reducer function name.

2) `extraReducers ` in createSlice() 
    The extraReducers field is used when you want your slice to handle actions that aren’t defined in the same slice. This is typically used for actions generated outside the slice — for example, actions from another slice, external actions, or async actions created using createAsyncThunk.

    Unlike reducers, extraReducers does not automatically generate action creators. Instead, you specify how the slice should handle specific action types, even if those actions come from elsewhere.

    Common use cases for extraReducers:
    - Handling actions created by createAsyncThunk (async operations like API calls).
   -  Handling actions from another slice.
   -  Handling actions dispatched by middleware or third-party libraries.


3) `createAsyncThunk()` 

In Redux, state updates are typically synchronous. However, modern applications often need to handle asynchronous operations like fetching data from an API, handling timeouts, or performing side effects. Redux by itself doesn't support asynchronous actions out of the box.

Redux Thunk is a middleware that extends Redux's capabilities, allowing you to write action creators that return a function (called a thunk) instead of a plain action object. This function can contain asynchronous code, and you can dispatch actions when asynchronous operations are complete.

```txt
Thunk: In programming, a thunk is a function that wraps an expression to delay its evaluation.
```
```txt
Redux Thunk Middleware: It allows you to write action creators that return a function instead of an action. This function can perform side effects and dispatch actions based on the outcome.
```

###### Why Use Redux Thunk?
- Asynchronous Actions: Handle asynchronous operations within action creators.
- Conditional Dispatching: Dispatch actions based on certain conditions or state.
- Access to dispatch and getState: Thunk functions receive dispatch and getState as arguments, giving you control over the action flow and access to the current state.

## RTK
- Automatic Action Types: Generates pending, fulfilled, and rejected action types.
- Simplifies Reducers: Reduces boilerplate in handling different states of an async action.